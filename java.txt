使用可能な同名の変数が複数ある場合、有効範囲の狭いものから優先される
String型の可変長引数はコンパイル時にString配列型と同様の扱い
interfaceは暗黙的に定数にpublic static finalを追加
抽象クラスは直接インスタンス化できない。サブクラスを定義して利用する
スーパークラスの変数に対して、サブクラスのobjであれば暗黙的に代入できる
参照型のキャストには継承関係が必要(あついはインターフェースを実装)
配列型はキャスト可能
サブクラスの変数にスーパークラスの変数を代入するとコンパイルエラー
インスタンス化で継承元の変数にアクセス可能
抽象クラス・インターフェースはインスタンス化できない
抽象クラスを継承した具象クラスは抽象メソッドをすべてオーバーライド
抽象クラスは実装しているインターフェースのメソッドを実装してもしなくてもよい
抽象クラスは抽象メソッドの実装不可( {} で定義できない)
ただし、具象メソッドであれば実装可能

継承すると継承元のコンストラクタが呼び出される

super()もthis()もどちらも先頭でしか呼び出しできない

super();this();の場合は？？？

trim()文字列最後の空白を取り除く
concut()代入し直さないとなんも変わらない
基本データ型はコピー渡し
booleanはswitch文の式に使えない
拡張for文は順番にしか取り出せない
for文は逆順も一つ飛ばしも可能
staticメンバからインスタンスメンバに直接アクセスできない

オーバーロードじは完全一致優先

1章（Javaの基本）
import文でワイルドカードを使ってもサブパッケージはインポートされない
無名パッケージに含まれるクラスには同じ無名パッケージに含まれるクラスからしかアクセスできない

2章（Javaのデータ型の操作）
数値リテラルのアンダースコアはリテラルの先頭と末尾、記号の前後には記述できない
記号には小数点を表す「.」、long型やfloat型リテラルを表す「L」や「F」が含まれる
メソッド名などの識別子には予約語は使えず、数字から始めてはいけない。使える記号はアンダースコアと通貨記号（￥や€）のみ。

3章（演算子と判定構造の使用）
暗黙の型変換一覧
byte → short, int, long, float, double
short → int, long, float, double
int → long, float, double
long → float, double
float → double
double → 不可
同じ文字列リテラルがプログラム内に再度登場するとインスタンスへの参照が使い回しされる（コンスタントプール）
new演算子を用いた場合は、その都度インスタンスが生成される　
switch分のcase式が返却できる型はint型以下の整数型とそのラッパークラス、文字と文字列、列挙型のいずれか
switch分のcase値はnullでない定数、もしくはコンパイル時に値が決まるリテラルでなければならない

4章（配列の作成と使用）
多次元配列の生成時には大カッコを一度にまとめて記述する必要はない（int[][] array[]でもOK）
配列の初期化演算子が使用できるのは変数宣言と同時か次元数を明示的に記述した場合のみ
配列の初期化演算子とnewを同時に使用する時は要素数を指定するとコンパイルエラー
int[] array = new int[2]{1, 2}はダメ

5章（ループ構造の使用）
コードブロックが使用できるのは全てのループ文、分岐、式、代入、return文、tryブロック、throw文

6章（メソッドとカプセル化の操作）
可変長引数としてまとめられることができるのは、同じ型の引数のみ
可変長引数は最後の引数にすること
プログラマが明示的にコンストラクタを記述した場合、デフォルトコンストラクタは追加されない
staticイニシャライザは複数定義可能で記述順に実行される

7章（継承の操作）
継承関係にあってもスーパークラスのコンストラクタとprivateなフィールドは引き継がれない
サブクラスのインスタンスはスーパークラスのインスタンスと差分のインスタンスからなる
継承関係にあるクラスで同名のフィールドが使われている場合、変数の型で宣言された方が使われる
メソッドの場合はメソッド内の指示に従う
アップキャストはコンパイル時に自動で判断される
ダウンキャストはコンパイラでは判断できないため、キャスト式が必須である
できない場合、コンパイルエラーは発生せず実行時例外となる
サブクラスのコンストラクタの先頭にはコンパイラによりsuper()が自動追加され、実行される

8章（例外の処理）
catchブロックとfinallyブロックの両方にreturn文がある場合、return文はfinallyブロックにより上書きされる

9章（Java APIの主要なクラスの操作）
ラムダ式の引数が１つの時、引数のカッコを省略可能。
ラムダ式の処理が１つの時、処理前後の中カッコを省略可能。戻り値がある時はreturn文は記述できない。
ラムダ式の処理前後の中カッコを省略しない場合は、return文を記述しなければならない。

main()メソッドの引数は、String配列型で宣言する必要がある
配列名のargsは任意の名称に変更可能

戻り値の型は修飾子よりも先に宣言できない

静的インポートとは、static変数やstaticメソッドをクラス名指定せずに使用するためのインポート機能
Import static ~~の順で書かないとダメ

booleanにnullだめ

charの対応するラッパークラスはCharacter

p55評価式

If文の条件式はbooleanでないとダメ
文字列で trueとかは不可

break文はループ文またはswitch文でしか使用できない
switchのcase文内にはbreak;がないと引き続き実行される

switch文の式には
byte  short  int  char
Integer  Character Byte Short

Switch文で同一のcase文を複数定義することができない

System.arraycopy()
コピー元配列名・コピー元開始添字・コピー先配列名・コピー先開始添字・コピーする要素数

String型は参照型のためnullも値として参入可能
double型もnull大丈夫
配列型の宣言時に要素数の指定はできない
String[5] array3;みたいなのはだめ

String[] str{"1","2","3","4","5"};

String[] s2;
s2 = str; //OK

String[] s4 = str; //ok

float 初期値 0.0f
double 0.0d
char '\u0000'
boolean false
String(参照型) null

配列は宣言と生成が別
宣言だけでは生成しないのでlength()メソッドなどは使えない

配列名を出力すると
[L + 配列型名 + ハッシュ値

オブジェクトの参照変数を System.out.println();すると
クラス名 +  hash
getClass()クラス名取得
isArray()配列か否か returnはboolean

int[][] array2D = {{0,1,2,4}{5,6}}
//,がないからだめ

int[][] ary = new int[2][]; //OK
ary[0] = new int[]{1,2,3}; //OK

"flag1".equals("flag2") //文字列の比較になる

while(num++ < 5); {
	System.out.println(num);
}
// numが6になり、条件式内がfalseになった時点でprint関数は呼ばれる

メソッドに戻り値ないときは、
return文を書かない or return;

暗黙の型変換は小さいやつから大きやつへの移行
キャストはその逆

staticメソッドは、オブジェクトで個々に管理するメソッド(インスタンスメソッド)とは異なり、クラスに属するメソッド
クラス名.staticメソッド名で呼び出し可能

staticメソッドからstaticメンバは呼び出し可能
staticメソッドからインスタンス変数・メソッドは呼び出し不可能
インスタンスメソッドからstaticメソッドは呼び出し可能

使用可能な同じ名前の変数が複数ある場合、有効範囲の狭い変数が優先される

コンストラクタのルール
・クラス名と同じ名前
・戻り値の型宣言は定義しない(した場合、メソッドとして認識される)
・必要に応じて引数を受け取ることができる
・オーバーロード可能

コンストラクタを明示的に定義していない場合、引数なしのデフォルトコンストラクタが生成される
もし、明示的に引数ありのコンストラクタを定義した場合に引数なしのコンストラクタを呼び出そうとするとコンパイルエラーが起きる

デフォルトコンストラクタはコンパイラによって生成される

this() の引数内でthisキーワードを使用して変数を指定できない
this(this.i, 10);みたいなのはコンパイルエラー

スーパークラス型の変数=サブクラス型の参照;
インターフェース型の変数=インターフェース実装クラスの参照;

サブクラス型変数=(サブクラス型)スーパークラス型変数

インターフェースと抽象クラスはnewできない
p204, 206

(Truth)sp.tell();
だとtell()メソッドを呼び出して、その戻り値をTruthにキャストしていることになる
変数spをTruthにキャストしてからtell()メソッドを呼び出したい場合は
((Truth)sp).tell();

class Parent{ }
class Child extends Parent{ }

class Main{
	public static void main (args[]){
		Child child = (Child) (new Parent());
	}
}
生成したのはParentオブジェクトだけでChildオブジェクトはまだ生成していない
存在しないChildg型へキャストすると、実行時エラーが発生する
参照変数のキャストは、コンパイル時ではなく実行時に行われる
コンパイルの段階でキャストのエラーを感知することはできない

参照型のキャストをおこなうには、クラス間に継承関係があるか、インターフェースを実装する関係が必要
配列型も参照型なので、任意の型へキャストできる

System.out.println();呼び出し時に参照情報を引数で渡すと、対象のオブジェクト内にあるtoString()メソッドが呼ばれる

スーパークラスで定義されているstaticメソッドを「super.メソッド名()」の形式で呼び出すことはできない
staticメソッドを呼び出す際は、「クラス名.メソッド名()」

自クラス内に定義されている引数なしのコンストラクタを呼び出す時はthis();

ClassNotFoundExceptionはコンパイラによってチェックされる

すべての例外クラスのスーパークラスとなるThrowableクラスでは、例外情報を操作するためのメソッドが提供されている

void printStackTrace()
エラーを追跡し、発生箇所を特定するエラーメッセージ(スタックトレース情報)を出力する
String getMessage()エラーメッセージを取得する
例外オブジェクトからエラーメッセージを取得するメソッド

チェックされる例外への対処法
・try-catchブロックを使用して例外が発生した箇所で例外処理をおこなう
・throwsキーワードを使用して、呼び出し元で例外処理をおこなう

例外がスローされるとその後の処理は行われない

catchする例外クラス間に継承関係が存在する場合、サブクラスはコードの上位に記述し、下位にスーパークラスを定義しないとコンパイルエラーが発生する
ひとつのcatch文で処理されれば別のcatch文で処理されることはない

throwsをメソッドに宣言することで呼び出し元に例外処理を行わせる
throwsが入っているメソッドは呼び出すときは要例外処理ということ

throwsのときnewはつけない

例外が発生するなら、どこかで処理するか、全部throwsするか

全部throwsするとコンパイルエラーにはならないが、実行時にエラーが発生すると処理できないので強制終了する
その際は、例外が発生するまでのプログラムは実行され、発生した例外クラス名と、例外がスローされたメソッドのスタックトレース情報が出力される

スーパークラスのメソッドにthrowsキーワードを使用した場合でも、オーバーライドするメソッドにthrowsを指定する必要はない
だが、throwsしていないメソッドをオーバーライドしたときにthrowsつけるとコンパイルエラー

自分より大きいクラスにキャストできない

StringIndexOutOfBoundsException

IOExceptionはjava.ioパッケージのクラス

NumberFormatExceptionはIllegalArgumentExceptionを継承している