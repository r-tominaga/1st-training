使用可能な同名の変数が複数ある場合、有効範囲の狭いものから優先される
String型の可変長引数はコンパイル時にString配列型と同様の扱い
interfaceは暗黙的に定数にpublic static finalを追加
抽象クラスは直接インスタンス化できない。サブクラスを定義して利用する
スーパークラスの変数に対して、サブクラスのobjであれば暗黙的に代入できる
参照型のキャストには継承関係が必要(あついはインターフェースを実装)
配列型はキャスト可能
サブクラスの変数にスーパークラスの変数を代入するとコンパイルエラー
インスタンス化で継承元の変数にアクセス可能
抽象クラス・インターフェースはインスタンス化できない
抽象クラスを継承した具象クラスは抽象メソッドをすべてオーバーライド
抽象クラスは実装しているインターフェースのメソッドを実装してもしなくてもよい
抽象クラスは抽象メソッドの実装不可( {} で定義できない)
ただし、具象メソッドであれば実装可能

継承すると継承元のコンストラクタが呼び出される

super()もthis()もどちらも先頭でしか呼び出しできない

super();this();の場合は？？？

trim()文字列最後の空白を取り除く
concut()代入し直さないとなんも変わらない
基本データ型はコピー渡し
booleanはswitch文の式に使えない
拡張for文は順番にしか取り出せない
for文は逆順も一つ飛ばしも可能
staticメンバからインスタンスメンバに直接アクセスできない

オーバーロードじは完全一致優先

1章（Javaの基本）
import文でワイルドカードを使ってもサブパッケージはインポートされない
無名パッケージに含まれるクラスには同じ無名パッケージに含まれるクラスからしかアクセスできない

2章（Javaのデータ型の操作）
数値リテラルのアンダースコアはリテラルの先頭と末尾、記号の前後には記述できない
記号には小数点を表す「.」、long型やfloat型リテラルを表す「L」や「F」が含まれる
メソッド名などの識別子には予約語は使えず、数字から始めてはいけない。使える記号はアンダースコアと通貨記号（￥や€）のみ。

3章（演算子と判定構造の使用）
暗黙の型変換一覧
byte → short, int, long, float, double
short → int, long, float, double
int → long, float, double
long → float, double
float → double
double → 不可
同じ文字列リテラルがプログラム内に再度登場するとインスタンスへの参照が使い回しされる（コンスタントプール）
new演算子を用いた場合は、その都度インスタンスが生成される　
switch分のcase式が返却できる型はint型以下の整数型とそのラッパークラス、文字と文字列、列挙型のいずれか
switch分のcase値はnullでない定数、もしくはコンパイル時に値が決まるリテラルでなければならない

4章（配列の作成と使用）
多次元配列の生成時には大カッコを一度にまとめて記述する必要はない（int[][] array[]でもOK）
配列の初期化演算子が使用できるのは変数宣言と同時か次元数を明示的に記述した場合のみ
配列の初期化演算子とnewを同時に使用する時は要素数を指定するとコンパイルエラー
int[] array = new int[2]{1, 2}はダメ

5章（ループ構造の使用）
コードブロックが使用できるのは全てのループ文、分岐、式、代入、return文、tryブロック、throw文

6章（メソッドとカプセル化の操作）
可変長引数としてまとめられることができるのは、同じ型の引数のみ
可変長引数は最後の引数にすること
プログラマが明示的にコンストラクタを記述した場合、デフォルトコンストラクタは追加されない
staticイニシャライザは複数定義可能で記述順に実行される

7章（継承の操作）
継承関係にあってもスーパークラスのコンストラクタとprivateなフィールドは引き継がれない
サブクラスのインスタンスはスーパークラスのインスタンスと差分のインスタンスからなる
継承関係にあるクラスで同名のフィールドが使われている場合、変数の型で宣言された方が使われる
メソッドの場合はメソッド内の指示に従う
アップキャストはコンパイル時に自動で判断される
ダウンキャストはコンパイラでは判断できないため、キャスト式が必須である
できない場合、コンパイルエラーは発生せず実行時例外となる
サブクラスのコンストラクタの先頭にはコンパイラによりsuper()が自動追加され、実行される

8章（例外の処理）
catchブロックとfinallyブロックの両方にreturn文がある場合、return文はfinallyブロックにより上書きされる

9章（Java APIの主要なクラスの操作）
ラムダ式の引数が１つの時、引数のカッコを省略可能。
ラムダ式の処理が１つの時、処理前後の中カッコを省略可能。戻り値がある時はreturn文は記述できない。
ラムダ式の処理前後の中カッコを省略しない場合は、return文を記述しなければならない。

main()メソッドの引数は、String配列型で宣言する必要がある
配列名のargsは任意の名称に変更可能

戻り値の型は修飾子よりも先に宣言できない

静的インポートとは、static変数やstaticメソッドをクラス名指定せずに使用するためのインポート機能
Import static ~~の順で書かないとダメ

booleanにnullだめ

charの対応するラッパークラスはCharacter

p55評価式

If文の条件式はbooleanでないとダメ
文字列で trueとかは不可

break文はループ文またはswitch文でしか使用できない
switchのcase文内にはbreak;がないと引き続き実行される

switch文の式には
byte  short  int  char
Integer  Character Byte Short

Switch文で同一のcase文を複数定義することができない

System.arraycopy()
コピー元配列名・コピー元開始添字・コピー先配列名・コピー先開始添字・コピーする要素数

String型は参照型のためnullも値として参入可能
double型もnull大丈夫
配列型の宣言時に要素数の指定はできない
String[5] array3;みたいなのはだめ

String[] str{"1","2","3","4","5"};

String[] s2;
s2 = str; //OK

String[] s4 = str; //ok

float 初期値 0.0f
double 0.0d
char '\u0000'
boolean false
String(参照型) null

配列は宣言と生成が別
宣言だけでは生成しないのでlength()メソッドなどは使えない

配列名を出力すると
[L + 配列型名 + ハッシュ値

オブジェクトの参照変数を System.out.println();すると
クラス名 +  hash
getClass()クラス名取得
isArray()配列か否か returnはboolean

int[][] array2D = {{0,1,2,4}{5,6}}
//,がないからだめ

int[][] ary = new int[2][]; //OK
ary[0] = new int[]{1,2,3}; //OK

"flag1".equals("flag2") //文字列の比較になる

while(num++ < 5); {
	System.out.println(num);
}
// numが6になり、条件式内がfalseになった時点でprint関数は呼ばれる

メソッドに戻り値ないときは、
return文を書かない or return;

暗黙の型変換は小さいやつから大きやつへの移行
キャストはその逆

staticメソッドは、オブジェクトで個々に管理するメソッド(インスタンスメソッド)とは異なり、クラスに属するメソッド
クラス名.staticメソッド名で呼び出し可能

staticメソッドからstaticメンバは呼び出し可能
staticメソッドからインスタンス変数・メソッドは呼び出し不可能
インスタンスメソッドからstaticメソッドは呼び出し可能

